diff --git a/teavm-runtime.js b/runtime.js
index 4c11730..3f54e86 100644
--- a/teavm-runtime.js
+++ b/runtime.js
@@ -13,7 +13,6 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-// !BEGINNING!
 
 let globalsCache = new Map();
 let stackDeobfuscator = null;
@@ -655,10 +654,21 @@ function wrapImport(importObj) {
     });
 }
 
-async function wrapImports(wasmModule, imports) {
+// patch start
+async function readImports(wasmModule, src) {
+    try {
+        return WebAssembly.Module.imports(wasmModule);
+    } catch (e) {
+        const { parseImports } = await import("./wasm-imports-parser.js");
+        return parseImports(typeof src === "string" ? await (await fetch(src)).arrayBuffer() : src);
+    }
+}
+// patch end
+
+async function wrapImports(wasmModule, imports, src) { // patch - src
     let promises = [];
     let propertiesToAdd = {};
-    for (let { module, name, kind } of WebAssembly.Module.imports(wasmModule)) {
+    for (let { module, name, kind } of await readImports(wasmModule, src)) { // patch - readImports
         if (kind !== "global" || module in imports) {
             continue;
         }
@@ -711,7 +721,7 @@ async function load(src, options) {
         options.installImports(importObj);
     }
     if (!options.noAutoImports) {
-        await wrapImports(module, importObj);
+        await wrapImports(module, importObj, src); // patch - src
     }
     let instance = await WebAssembly.instantiate(module, importObj);
 
@@ -821,4 +831,6 @@ async function fetchExternalDebugInfo(path, debugInfoLocation, options) {
         return null;
     }
     return new Int8Array(await response.arrayBuffer());
-}
\ No newline at end of file
+}
+
+export { load, defaults, wrapImport };
